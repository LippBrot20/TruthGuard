WebSocket – Wikipedia WebSocket aus Wikipedia, der freien Enzyklopädie Zur Navigation springen Zur Suche springen WebSocket-Protokoll Familie: Internetprotokollfamilie Einsatzgebiet: bidirektionale Verbindung zwischen einer Webanwendung und einem WebSocket-Server Port: 80/TCP, 443/TCP WebSocket im TCP/IP-Protokollstapel : Anwendung WebSocket Transport TCP Internet IP ( IPv4 , IPv6 ) Netzzugang Ethernet Token Bus Token Ring FDDI … Standards: RFC 6455 [ 1 ] Das WebSocket-Protokoll ist ein auf TCP basierendes Netzwerkprotokoll , das entworfen wurde, um eine bidirektionale Verbindung zwischen einer Webanwendung und einem WebSocket-Server bzw. einem Webserver , der auch WebSockets unterstützt, herzustellen. Inhaltsverzeichnis 1 Vorteile gegenüber reinem HTTP 2 URI-Schema 3 Der WebSocket-Protokoll-Handshake 3.1 Anfrage des Clients 3.2 Antwort des Servers 4 Beispiel 5 Erweiterungen 6 Browser-Unterstützung 7 Literatur 8 Weblinks 9 Einzelnachweise Vorteile gegenüber reinem HTTP [ Bearbeiten | Quelltext bearbeiten ] Während bei einer reinen HTTP -Verbindung jede Aktion des Servers eine vorhergehende Anfrage des Clients erfordert, reicht es beim WebSocket-Protokoll, wenn der Client die Verbindung öffnet. Der Server kann dann diese offene Verbindung aktiv verwenden und neue Informationen an den Client ausliefern, ohne auf eine neue Verbindung des Clients zu warten. Eine vom Server initiierte Übertragung ist bei einer reinen HTTP-Verbindung nur durch verzögertes Antworten auf eine vom Client initiierte Anfrage möglich ( long Polling ). Seit HTTP/2 kann der Server auch Push-Meldungen absetzen. Zudem entfallen bei WebSockets die durch den HTTP-Header verursachten zusätzlichen Daten, die bei jeder Anfrage einige hundert Bytes umfassen können. Technisch betrachtet startet bei WebSocket, wie bei HTTP, der Client eine Anfrage, mit dem Unterschied, dass nach der Übertragung der Daten zum Verbindungsaufbau die zugrundeliegende TCP -Verbindung bestehen bleibt und asynchrone Übertragungen in beide Richtungen ermöglicht. URI-Schema [ Bearbeiten | Quelltext bearbeiten ] Die WebSocket-Protokoll-Spezifikation definiert zwei neue URI -Schemata, ws: für unverschlüsselte, und wss: für verschlüsselte Verbindungen. Der WebSocket-Protokoll-Handshake [ Bearbeiten | Quelltext bearbeiten ] Zu Beginn jeder Verbindung führen Server und Client einen sogenannten Handshake durch. Dieser ähnelt dem HTTP-Header und ist vollständig abwärtskompatibel zu diesem, was die Nutzung des Standard-HTTP-Ports „80“ zugleich für normale HTTP-Kommunikation als auch für die Websocket-Nutzung ermöglicht. Der Handshake beinhaltet außerdem weitere Informationen (z. B. die verwendete Protokollversion). Anfrage des Clients [ Bearbeiten | Quelltext bearbeiten ] Im Folgenden ist ein Beispielhandshake des siebzehnten Protokollentwurfs ( draft-ietf-hybi-thewebsocketprotocol-17 ) dargestellt und erläutert: [ 2 ] Achtung: Ältere Protokollentwürfe können sehr stark von dieser Version des Protokolls abweichen, da es aufgrund von Sicherheitsbedenken umgestaltet wurde. Dies betrifft insbesondere die Entwürfe vor draft-ietf-hybi-thewebsocketprotocol-04 . GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== Origin: http://example.com Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Wie auch im HTTP-Protokoll gibt der Client an, auf welche Ressource (hier: /chat ) und auf welchen Host (hier: server.example.com ) er zugreifen möchte. Außerdem fordert der Client ein Upgrade auf das Websocket-Protokoll. Der zufällig generierte „Sec-WebSocket-Key“ dient zur Überprüfung, ob der Server die Anfrage tatsächlich gelesen und verstanden hat ( siehe Abschnitt Antwort des Servers ). Unter „Sec-WebSocket-Protocol“ hat der Client die Möglichkeit, auf das Websocket-Protokoll aufbauende Protokolle anzugeben, die die Clientanwendung unterstützt (hier: ein Chat-Protokoll). Selbsterklärend sollte unter „Sec-WebSocket-Version“ die verwendete Protokollversion angegeben werden. Antwort des Servers [ Bearbeiten | Quelltext bearbeiten ] Auf die obige Beispielanfrage könnte ein Websocket-Server beispielsweise wie folgt antworten: HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= Sec-WebSocket-Protocol: chat Durch den HTTP-Statuscode 101 und die folgenden zwei Zeilen erklärt der Server, dass er mit dem Wechsel des Protokolls einverstanden ist. Von diesem Zeitpunkt an verwenden beide ein binäres Protokoll, das nicht mehr HTTP-kompatibel ist. Es ist in Pakete aufgeteilt, die als Binär oder Text, als Ping oder Pong oder als Ende der Verbindung markiert sind und die Länge des Inhalts angeben. [ 3 ] Der zurückgesendete Schlüssel unter „Sec-WebSocket-Accept“ dient der Verifikation, dass der Server die Anfrage des Clients gelesen hat. Er wird wie folgt erstellt: An den oben erwähnten, Base64 -kodierten String, den der Client sendet („Sec-WebSocket-Key“) wird der Globally Unique Identifier 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 angehängt. Daraufhin wird ein SHA1-Hash des entstandenen Schlüssels erstellt und Base64-kodiert. Anzumerken ist hierbei, dass der ursprünglich empfangene Schlüssel zwar Base64-kodiert ist, jedoch zu keinem Zeitpunkt dekodiert wird. In diesem Beispiel gibt der Server zusätzlich an, dass er das angeforderte Protokoll „chat“ kennt („Sec-WebSocket-Protocol“). Beispiel [ Bearbeiten | Quelltext bearbeiten ] WebSocket Client in JavaScript var socket = new WebSocket ( urlToWebsocketServer ); // callback-Funktion wird gerufen, wenn die Verbindung erfolgreich aufgebaut werden konnte socket . onopen = function () { console . log ( "Verbindung wurde erfolgreich aufgebaut" ); }; // callback-Funktion wird gerufen, wenn eine neue Websocket-Nachricht eintrifft socket . onmessage = function ( messageEvent ) { console . log ( messageEvent . data ); }; // callback-Funktion wird gerufen, wenn ein Fehler auftritt socket . onerror = function ( errorEvent ) { console . log ( "Error! Die Verbindung wurde unerwartet geschlossen" ); }; socket . onclose = function ( closeEvent ) { console . log ( 'Die Verbindung wurde geschlossen --- Code: ' + closeEvent . code + ' --- Grund: ' + closeEvent . reason ); }; Erweiterungen [ Bearbeiten | Quelltext bearbeiten ] Die Spezifikation erlaubt die Erweiterung des Websocket-Protokolls durch definierte „Extensions“. Diese werden zwischen Client und Server ausgehandelt. Beispiele: WebSocket Per-frame Compression A Multiplexing Extension for WebSockets The MessageBroker WebSocket Subprotocol Browser-Unterstützung [ Bearbeiten | Quelltext bearbeiten ] Auf WebKit basierende Browser (z. B. Google Chrome , Apple Safari ) Opera , ab Version 10.70 Microsoft Edge , ab erster Version Mozilla Firefox , ab Version 4 [ 4 ] Internet Explorer , ab Version 10.0 Literatur [ Bearbeiten | Quelltext bearbeiten ] Peter Leo Gorski, Luigi Lo Iacono, Hoai Viet Nguyen: WebSockets – Moderne HTML5-Echtzeitanwendungen entwickeln , Hanser, München und Wien 2015, ISBN 978-3-446-44371-6 Weblinks [ Bearbeiten | Quelltext bearbeiten ] RFC : 6455 – The WebSocket Protocol Version 13 . 2011 (englisch). The WebSocket API – WHATWG Entwurf für die API-Spezifikation HTML5 Server-Push Technologies, Part 2. community.oracle.com; Einführung in WebSockets WebSocket: Annäherung an Echtzeit im Web . heise Developer Einzelnachweise [ Bearbeiten | Quelltext bearbeiten ] ↑ RFC : 6455 – The WebSocket Protocol Version 13 . 2011 (englisch). ↑ Der vorliegende Beispielhandshake entstammt der siebzehnten Version des WebSocket Protocol Draft der IETF ↑ RFC : 6455 – The WebSocket Protocol Version 13 . 2011, Abschnitt 5.2: Base Framing Protocoll . (englisch). ↑ developer.mozilla.org V – D Standards des World Wide Web Consortiums (W3C) Empfehlungen ActivityPub | ARIA | Canonical XML | CDF | CSS | DOM | Geolocation API | HTML | HTML5 | InkML | ITS | JSON-LD | MathML | OWL | P3P | PLS | PNG | RDF | RDF-Schema | RIF | SCXML | SISR | SKOS | SMIL | SOAP | SRGS | SSML | SVG | SPARQL | Timed Text | Turtle | VoiceXML | WSDL | XForms | XHTML | XHTML+RDFa | XInclude | XLink | XML | XML Base | XML-Encryption | XML Events | XML Information Set | XML Namespace | XML Schema | XML Signature | XPath | XPointer | XProc | XQuery | XSL | XSL-FO | XSLT ( Elemente ) Arbeitsentwürfe und Kandidaten CCXML | CURIE | SMIL Timesheets | sXBL | WICD | XFrames | XBL | XHTML+MathML+SVG | XMLHttpRequest Anmerkungen XAdES | XFDL | XHTML+SMIL | XUP Richtlinien Web Content Accessibility Guidelines | Multimodal Interaction Activity | Markup Validation Service Initiativen Web Accessibility Initiative Abgerufen von „ https://de.wikipedia.org/w/index.php?title=WebSocket&oldid=234984963 “ Kategorien : JavaScript-Programmierschnittstelle Internet-Anwendungsprotokoll Navigationsmenü Meine Werkzeuge Nicht angemeldet Diskussionsseite Beiträge Benutzerkonto erstellen Anmelden Namensräume Artikel Diskussion Deutsch Ansichten Lesen Bearbeiten Quelltext bearbeiten Versionsgeschichte Weitere Suche Navigation Hauptseite Themenportale Zufälliger Artikel Mitmachen Artikel verbessern Neuen Artikel anlegen Autorenportal Hilfe Letzte Änderungen Kontakt Spenden Werkzeuge Links auf diese Seite Änderungen an verlinkten Seiten Spezialseiten Permanenter Link Seiten­­informationen Artikel zitieren Kurzlink QR-Code herunterladen Drucken/​exportieren Als PDF herunterladen Druckversion In anderen Projekten Wikidata-Datenobjekt In anderen Sprachen العربية Български Català Čeština Ελληνικά English Español Eesti فارسی Français Magyar Հայերեն Bahasa Indonesia Italiano 日本語 한국어 Bahasa Melayu Nederlands Polski Português Русский Svenska Türkçe Українська Tiếng Việt 中文 閩南語 / Bân-lâm-gú Links bearbeiten
Single-Page-Webanwendung – Wikipedia Single-Page-Webanwendung aus Wikipedia, der freien Enzyklopädie Zur Navigation springen Zur Suche springen Als Single-Page-Webanwendung ( englisch single-page application , kurz SPA ) oder Einzelseiten-Webanwendung wird eine Webanwendung bezeichnet, die aus einem einzigen HTML -Dokument besteht und deren Inhalte dynamisch nachgeladen werden. Im Gegensatz dazu bestehen klassische Webanwendungen aus mehreren, untereinander verlinkten HTML-Dokumenten. Hierdurch wird die Grundlage geschaffen, eine Webanwendung in Form einer Rich-Client- bzw. Fat-Client -Verteilung zu entwickeln. Eine verstärkte clientseitige Ausführung der Webanwendung ermöglicht eine Reduzierung der Serverlast sowie die Umsetzung von selbstständigen Webclients, die beispielsweise eine Offline-Unterstützung anbieten. Inhaltsverzeichnis 1 Ziele und Anforderungen 2 Einsatzszenarien 3 Mögliche JavaScript-Frameworks für SPAs 4 Techniken 5 Siehe auch 6 Weblinks 7 Einzelnachweise Ziele und Anforderungen [ Bearbeiten | Quelltext bearbeiten ] Skizzierung des Ablaufs einer Single-Page-Webanwendung Durch die Nutzung einer einzigen Webseite als Fundament für eine vollständige Webanwendung kann die Client-Server-Kommunikation reduziert werden. Die Webseite kann zur Laufzeit der Applikation dynamisch erweitert werden. Auf diese Weise kann auf eine Navigation zwischen verschiedenen Webseiten verzichtet und die Wartezeit reduziert werden. Bei dem sonst üblichen Wechsel von Unterseiten einer Webanwendung im Webbrowser wird sämtliche clientseitige Präsentationslogik beendet und auf der nächsten Webseite neu begonnen. Ein solches Verhalten unterbindet andauernde clientseitige Vorgänge sowie die Nutzung einer durchgängigen WebSocket -Verbindung. Ein weiteres Merkmal von SPAs wird häufig mit dem Titel „offline-friendly“ bezeichnet. Durch die vollständige Umsetzung der Präsentationsschicht auf dem Client ist es möglich, mithilfe der Web-Storage -Funktion persistente Zwischenspeicher anzulegen. Für den Fall, dass der Nutzdatenserver nicht erreichbar ist, können Daten aus dem Zwischenspeicher verwendet werden. Die Anwendung kann somit weiterhin auf dem Client betrieben werden, ohne dass eine Verbindung zum Server bestehen muss. Der Einsatz einer clientseitigen Persistierung kann über die Bildung von Zwischenspeicher hinausgehen und zu einer verteilten Persistenz führen. In solchen verteilten Datenhaltungen kann jeder Client als einzelner Datenknoten betrachtet werden, welcher bei einer bestehenden Kommunikationsverbindung seinen Datenvorrat mit anderen Teilnehmerknoten synchronisiert. Die Eigenschaft „offline-friendly“ verweist ebenfalls auf die Portierbarkeit von Single-Page-Applikationen auf mobile Endgeräte hin. Sogenannte mobile HTML5-Offline-Apps basieren größtenteils auf der gleichen Infrastruktur wie SPAs. Bei Single-Page-Webanwendungen findet eine Dezentralisierung statt. Während in bisherigen Vorgehensweisen der Webserver die zentrale Einheit zur Steuerung der Präsentation war, stellt dieser in SPAs nur noch benötigte Daten bereit. Die Webanwendung wird in zwei getrennte Systeme segmentiert. Folgende drei Regeln für die Segmentierung bei Single-Page-Webanwendungen können definiert werden: [ 1 ] Der Sitzungszustand wird in der Client-Applikation gespeichert, nicht im Server. Durch die Realisierung der Webanwendung auf Basis eines einzelnen HTML-Dokuments bleibt der Zustand der Anwendung im Webclient stets erhalten. Das erneute Laden dieses HTML-Dokuments ist mit einem Neustart der Anwendung gleichzusetzen. Hinzu kommt, dass HTTP ein ressourcenorientiertes und zustandsloses Protokoll ist. Die sonst übliche künstliche Emulation von Sitzungszuständen auf Basis von Cookies ist bei Single-Page-Webanwendungen somit nicht mehr nötig. Die Art der Sitzungsverwaltung ist ein klassisches Entwurfsproblem bei verteilten Anwendungen, welches sich stark auf die Skalierbarkeit und Performanz der Anwendung auswirken kann. Durch die clientseitige Sitzungsverwaltung können die serverseitigen Funktionalitäten zustandslos implementiert werden. Das bedeutet, dass bei einer Lastverteilung ein beliebiger Serverknoten antworten kann. Des Weiteren werden serverseitig keine Ressourcen pro aktiver Clientsitzung verbraucht. Der Webclient ist eine unabhängige Einheit und baut auf verschiedenen Services auf. Dies erlaubt, dass der Webclient selbstständig auf Benutzeraktionen reagieren kann. Auf eine Vielzahl von Client-Server-Roundtrips kann verzichtet werden, wodurch der Datenverkehr reduziert wird, die Anwendung schneller reagiert und die User Experience zunimmt. Des Weiteren kann der Client losgelöst von einem Server entwickelt werden und muss die Services nur einsetzen, wenn diese benötigt werden. Die verwendeten Services treffen keine Annahmen darüber, wie der Webclient die angebotenen Dienste einsetzt. Die Serverseite kann ebenfalls – losgelöst vom Client – implementiert und getestet werden. Durch diese Entkopplung können die bereitgestellten Dienste ebenfalls in verschiedenen anderen Projekten verwendet werden. Einsatzszenarien [ Bearbeiten | Quelltext bearbeiten ] Große Benutzerzahlen Einsatzgebiete mit großen Benutzerzahlen sind das typische Standardszenario für Single-Page-Webanwendungen. Erfolgreiche Projekte wie Facebook, Google Gmail, Google Maps und Twitter haben hierbei Pionierarbeit geleistet. Alle Beispiele sind im B2C-Markt vertreten. Hierbei ist mit großen Benutzeranzahlen zu rechnen. Um die Serverlast zu reduzieren und zeitgleich eine optimale Skalierbarkeit der Anwendung zu realisieren, bietet sich das SPA-Paradigma an. Der Betrieb einer ausschließlich clientseitigen Präsentation und Sitzungsverwaltung entlastet die serverseitige Infrastruktur und erlaubt eine Skalierung ohne verteilte Caches auf der Ebene des Anwendungsservers („Dezentralisierung“). Offlineszenarien Die Realisierung von Offlineszenarien ist zwar auf Basis des HTML5 Application Cache auch für klassische Webanwendungen möglich, jedoch erfolgt in einem solchen Szenario lediglich eine clientseitige Speicherung von serverseitig generierten HTML-Dokumenten. Geschäftslogiken können nicht ausgeführt werden. Offlineszenarien auf Basis des SPA-Paradigmas erlauben im Gegensatz dazu die Ausführung von clientseitiger Fachkonzeptlogik in einem Offlineszenario. Begrenzt wird dies im Endeffekt lediglich durch die Verfügbarkeit der benötigten Daten. Zur clientseitigen Datenbereitstellung erlaubt das SPA-Paradigma, die Implementierung von Datenbereitstellungsstrategien, wie Caching, Replikation oder Hoarding. Hierdurch kann ein produktiver Einsatz einer Webanwendung in einem Offlineszenario angeboten werden. Kleine Projekte Ein überschaubares Fachkonzept, wie bei Unternehmensauftritten oder „Product-Landing-Pages“, bietet sich für eine Implementierung nach dem SPA-Paradigma an. Aufgrund des kleinen Fachkonzepts hält sich die Menge der Geschäftslogik, welche clientseitig umgesetzt wird, in Grenzen. Das Hauptaugenmerk bei der Implementierung befindet sich auf der Präsentationsschicht. Das SPA-Paradigma kann in diesem Einsatzgebiet eine hohe Interaktivität bieten und erlaubt die Umsetzung einer ansprechenden Bedienoberfläche. Hohe Interaktivität Für Anwendungen wie Computerspiele bietet der Webbrowser gerade im 2D-Bereich eine plattformunabhängige Infrastruktur an. In diesem Anwendungsbereich sind eine hohe Interaktivität und kurze Latenzzeiten erforderlich. Die Implementierung solcher Anwendungen wurde in der Vergangenheit bereits als Plug-in unterstützte SPA mit Adobe Flash oder Microsoft Silverlight durchgeführt. Mit dem Einzug von HTML5, Canvas, WebSockets und WebGL stellen RIA/JS-SPAs eine Alternative dar. Die auf JavaScript basierende Umsetzung bietet den Vorteil, dass ausschließlich Webstandards eingesetzt werden, welche ebenfalls auf mobilen Endgeräten zur Verfügung stehen. Auf diese Weise können mit einer Implementierung mehrere Zielsysteme adressiert werden. Hybride Web-Apps Das SPA-Paradigma eignet sich für die Einbettung in native mobile Anwendungen. Bei sogenannten hybriden Anwendungen wird ein Webclient über ein Framework, wie Apache Cordova , eingebettet. Die Art und Weise der Implementierung einer solchen Web-App erfolgt clientnah und meist nach dem SPA-Paradigma. Mögliche JavaScript-Frameworks für SPAs [ Bearbeiten | Quelltext bearbeiten ] Folgende MV*-Frameworks (MV* als Platzhalter für MVC , MVVM , MVP , …) können zur Implementierung eines SPA-Webclients verwendet werden: AngularJS Angular Aurelia.io Backbone.js DurandalJS Ember.js Knockout.js OpenUI5 React Svelte Vue.js Techniken [ Bearbeiten | Quelltext bearbeiten ] Es gibt verschiedene Ansätze, um eine Kommunikation zwischen SPAs und Servern zu ermöglichen. Die unten aufgeführten Beispiele unterscheiden sich vor allem hinsichtlich ihrer Richtung des Datenflussen und in ihrem Verbindungsaufbau: HTTP-Requests ( Ajax -Techniken) WebSockets Server-sent events (SSE) Siehe auch [ Bearbeiten | Quelltext bearbeiten ] REST Rich Internet Application Weblinks [ Bearbeiten | Quelltext bearbeiten ] Single-page applications Website mit Definitionen und SPA-Beispielen (englisch) Migrating Multi-page Web Applications to Single-page Ajax Interfaces Delft University of Technology (englisch) The Single Page Interface Manifesto (englisch) Single Page Websites Auflistung von SPA-Sites (englisch) Single-Page-Webanwendungen Präsentation mit Referenzarchitektur zum Thema SPA (deutsch) Einzelnachweise [ Bearbeiten | Quelltext bearbeiten ] ↑ Experiences on a Design Approach for Interactive Web Applications. Abgerufen am 28. März 2021 . Abgerufen von „ https://de.wikipedia.org/w/index.php?title=Single-Page-Webanwendung&oldid=245194444 “ Kategorie : Webanwendung Navigationsmenü Meine Werkzeuge Nicht angemeldet Diskussionsseite Beiträge Benutzerkonto erstellen Anmelden Namensräume Artikel Diskussion Deutsch Ansichten Lesen Bearbeiten Quelltext bearbeiten Versionsgeschichte Weitere Suche Navigation Hauptseite Themenportale Zufälliger Artikel Mitmachen Artikel verbessern Neuen Artikel anlegen Autorenportal Hilfe Letzte Änderungen Kontakt Spenden Werkzeuge Links auf diese Seite Änderungen an verlinkten Seiten Spezialseiten Permanenter Link Seiten­­informationen Artikel zitieren Kurzlink QR-Code herunterladen Drucken/​exportieren Als PDF herunterladen Druckversion In anderen Projekten Wikidata-Datenobjekt In anderen Sprachen العربية Català English Español Eesti فارسی Français עברית Italiano 日本語 한국어 മലയാളം Nederlands Norsk bokmål Polski Português Русский Српски / srpski ไทย Türkçe Українська 中文 Links bearbeiten
Vapor – Wikipedia Vapor aus Wikipedia, der freien Enzyklopädie Zur Navigation springen Zur Suche springen Vapor Basisdaten Entwickler Tanner Nelson, Logan Wright u. a. Erscheinungsjahr 2016 Aktuelle Version 4.55.0 [ 1 ] ( 26. Januar 2022 ) Betriebssystem macOS , Ubuntu Programmier­sprache Swift Kategorie Webframework Lizenz MIT-Lizenz https://vapor.codes/ Vapor ist ein Open-Source - Webframework , das in Swift geschrieben wurde. Es kann zum Erstellen von RESTful -APIs, Webanwendungen und Echtzeitanwendungen mit WebSockets verwendet werden. Zusätzlich zum Kernframework bietet Vapor eine Objektrelationale Abbildung (ORM) namens Fluent , eine Vorlagensprache ( Leaf ) und Pakete, um die Benutzerauthentifizierung und -autorisierung zu vereinfachen. [ 2 ] Der Quelltext von Vapor wird auf GitHub gehostet und unter der MIT-Lizenz lizenziert. [ 3 ] Vapor ist seit 2016 Teil der Swift-Arbeitsgruppe für Server-APIs. [ 4 ] [ 5 ] Inhaltsverzeichnis 1 Geschichte 1.1 Releases 2 Features 3 Einzelnachweise Geschichte [ Bearbeiten | Quelltext bearbeiten ] Vapor 0.1.0 wurde einen Monat nach dem Start von Apples Open-Source -Projekt Swift als Proof of Concept für Serveranwendungen für Swift veröffentlicht und hat am 3. Dezember 2015 mit der Unterstützung der Linux -Plattform begonnen. [ 6 ] Vapor 1.0 [ 7 ] erschien September 2016, gefolgt von der Veröffentlichung von Vapor 2.0 im Mai 2017. [ 8 ] Das Framework wurde für die Version 3.0 neu geschrieben [ 9 ] und wurde auf Apples Netzwerk-Framework SwiftNIO aufgebaut. [ 10 ] Version 4.0 verwendet SwiftNIO 2.0 und ist in das Swift Server Working Group -Ökosystem eingebunden, außerdem nutzt Fluent nun die ab Swift 5.1 verfügbaren property wrapper . [ 11 ] Releases [ Bearbeiten | Quelltext bearbeiten ] Version Erscheinungsdatum Swift Version 1.0 15. September 2016 3.0 2.0 17. Mai 2017 3.1 3.0 4. Mai 2018 4.1 4.0 9. April 2020 5.2 Features [ Bearbeiten | Quelltext bearbeiten ] Vapor unterstützt folgende Funktionen: [ 12 ] Asynchrones IO-System Authentifizierung: basic, JWT und Passwort Cache: Redis und in-Memory Konsolen-Formatierung Content-Darstellung: JSON , multipart und URL-kodiert Krypto: RNG, ciphers, digests, RSA Fluent ORM : MySQL , PostgreSQL und SQLite HTTP Client und Server Loggen URL-Routing WebSocket Client und Server Einzelnachweise [ Bearbeiten | Quelltext bearbeiten ] ↑ github.com . (abgerufen am 4. Februar 2022). ↑ Vapor GitHub Organization. Abgerufen am 3. April 2018 . ↑ vapor/vapor LICENSE at master. 23. Februar 2018, abgerufen am 3. April 2018 . ↑ Swift Server APIs. 25. Oktober 2016, abgerufen am 22. Mai 2018 . ↑ Swift Blog: Server APIs Work Group. 25. Oktober 2016, abgerufen am 22. Mai 2018 . ↑ Swift is Open Source. 3. Dezember 2015, abgerufen am 3. April 2018 . ↑ Vapor 1.0.0 Release. 15. September 2016, abgerufen am 3. April 2018 . ↑ Vapor 2.0.0 Release. 17. Mai 2018, abgerufen am 3. April 2018 . ↑ Vapor 3.0.0 released. 4. Mai 2018, abgerufen am 23. Mai 2018 . ↑ Apple Inc.: Swift.org. In: Swift.org. Abgerufen am 4. Oktober 2018 (englisch). ↑ forums.swift.org. Abgerufen am 4. Februar 2022 (englisch). ↑ Vapor Docs. In: docs.vapor.codes. Abgerufen am 22. Mai 2018 (englisch). Abgerufen von „ https://de.wikipedia.org/w/index.php?title=Vapor&oldid=243994307 “ Kategorie : Webframework Versteckte Kategorie: Wikipedia:Vorlagenfehler/Vorlage:Cite web/temporär Navigationsmenü Meine Werkzeuge Nicht angemeldet Diskussionsseite Beiträge Benutzerkonto erstellen Anmelden Namensräume Artikel Diskussion Deutsch Ansichten Lesen Bearbeiten Quelltext bearbeiten Versionsgeschichte Weitere Suche Navigation Hauptseite Themenportale Zufälliger Artikel Mitmachen Artikel verbessern Neuen Artikel anlegen Autorenportal Hilfe Letzte Änderungen Kontakt Spenden Werkzeuge Links auf diese Seite Änderungen an verlinkten Seiten Spezialseiten Permanenter Link Seiten­­informationen Artikel zitieren Kurzlink QR-Code herunterladen Drucken/​exportieren Als PDF herunterladen Druckversion In anderen Projekten Wikidata-Datenobjekt In anderen Sprachen English فارسی 中文 Links bearbeiten
Modernizr – Wikipedia Modernizr aus Wikipedia, der freien Enzyklopädie Zur Navigation springen Zur Suche springen Modernizr Basisdaten Entwickler Faruk Ateş mithilfe von Paul Irish, Alex Sexton, Ryan Seddon, Patrick Kettner, Stu Cox, Richard Herrera, und 185 Mitwirkende der GitHub-Community [ 1 ] [ 2 ] [ 3 ] Erscheinungsjahr 2009 [ 1 ] Aktuelle Version 3.13.0 [ 4 ] (15. August 2023 [ 4 ] ) Aktuelle Vorabversion 3.0.0-pre [ 5 ] ( 27. Oktober 2014 ) Betriebssystem Plattformunabhängig Programmier­sprache JavaScript [ 6 ] Kategorie Featureerkennung (englisch Feature detection ) [ 6 ] Lizenz MIT-Lizenz [ 7 ] ; vom 14. Juni 2010 [ 8 ] bis zum 15. September 2012 [ 9 ] dual lizenziert MIT- BSD deutschsprachig nein modernizr.com Modernizr ist eine JavaScript - Bibliothek , welche es ermöglicht, HTML5 - und CSS3 -Features in verschiedenen Browsern zu erkennen. [ 6 ] Dies ermöglicht es JavaScript, nicht vorhandene Features zu umgehen oder Workarounds , wie etwa einen Shim aufzurufen, um diese nachzubilden. Modernizr hat zum Ziel, das Erkennen von Browserfeatures komplett zu standardisieren. [ 10 ] Inhaltsverzeichnis 1 Überblick 2 Funktionalität 3 Einsatz 4 Begrenzungen 5 Beispiele 5.1 JavaScript-Beispiel 5.2 CSS-Beispiel 6 Preise und Ehrungen 7 Siehe auch 8 Weblinks 9 Einzelnachweise Überblick [ Bearbeiten | Quelltext bearbeiten ] Viele neue HTML5- und CSS 3-Features stehen bereits in mindestens einem der großen Browser zur Verfügung. Modernizr erkennt, ob der aktuelle Browser ein bestimmtes Feature implementiert hat. [ 11 ] [ 12 ] [ 13 ] [ 14 ] Dies ermöglicht es Entwicklern, die Vorteile neuer Features in unterstützenden Browsern zu erzielen und Fallbacks für Browser zu entwickeln, die diese neuen Features nicht bieten. Funktionalität [ Bearbeiten | Quelltext bearbeiten ] Modernizr setzt auf das Erkennen von Features (englisch feature detection ), anstatt mithilfe der Browsereigenschaften zu überprüfen, ob der Browser etwas kann oder nicht. Die Entwickler nehmen an, dass feature detection verlässlicher ist, da derselbe HTML-Renderer nicht unbedingt die gleichen Funktionalitäten in verschiedenen Browsern und Browserversionen zur Verfügung stellt. Darüber hinaus kann der User Agent durch den Benutzer geändert worden sein, vor allem um Webseiten, die bestimmte Browserfunktionalitäten erwarten, diese vorzutäuschen. Modernizr stellt mehr als 250 Tests für „ next generation features “ zur Verfügung, dann erstellt es ein JavaScript-Objekt (namens „Modernizr“), das die Testergebnisse als Booleschen Wert beinhaltet. Es erweitert auch das HTML -Element um Klassen, die die Testergebnisse widerspiegeln. Um bestimmte CSS-Features zu erkennen, erstellt Modernizr oft Elemente, weist diesen bestimmte CSS- Styles zu und versucht diese zu überprüfen, da Browser, die das jeweilige CSS- Feature implementieren, etwas sinnvolles zurückgeben, während sonst nichts oder Werte wie „ undefined “ zurückgeben werden. Viele Tests in der Dokumentation beinhalten ein Praxisbeispiel, um zu demonstrieren, wie ein bestimmter Test eingesetzt werden kann. Einsatz [ Bearbeiten | Quelltext bearbeiten ] Modernizr startet selbstständig. Es gibt keine Initialisierungsfunktion, die aufgerufen werden muss. Nachdem Modernizr fertig ist, erstellt es ein globales „Modernizr“-Objekt, das Boolesche Werte enthält. Wenn ein Browser zum Beispiel die Canvas API unterstützt, wird Modernizr.canvas „ true “ ausgeben, sonst „ false “. if ( Modernizr . canvas ) { // Der Browser unterstützt Canvas } else { // Der Browser unterstützt Canvas nicht } Begrenzungen [ Bearbeiten | Quelltext bearbeiten ] Modernizr fügt dem Browser keine fehlenden Funktionalitäten hinzu oder simuliert diese. Dies ist Aufgabe sogenannter Shims wie dem HTML5 Shiv , diese JavaScript- Bibliothek fügt Unterstützung für HTML5-Elemente in den Internet-Explorer -Versionen vor 9 hinzu, [ 15 ] solche Polyfills werden auch in der Modernizr-Dokumentation aufgelistet. [ 16 ] Beispiele [ Bearbeiten | Quelltext bearbeiten ] JavaScript-Beispiel [ Bearbeiten | Quelltext bearbeiten ] <!DOCTYPE html> < html class = "no-js" lang = "en" > < head > < title > Modernizr – JavaScript Beispiel </ title > < script src = "path/to/modernizr.js" ></ script > </ head > < body > < p id = "result" ></ p > < script > elem = document . getElementById ( 'result' ); if ( ! Modernizr . websockets ) { elem . innerHTML = 'Dieser Browser unterstützt keine WebSockets.' ; } else { elem . innerHTML = 'Dieser Browser unterstützt WebSockets.' ; } </ script > </ body > </ html > CSS-Beispiel [ Bearbeiten | Quelltext bearbeiten ] <!DOCTYPE html> < html class = "no-js" lang = "en" > < head > < title > Modernizr – CSS Beispiel </ title > < style > . wsno , . wsyes { display : none ; } /* Modernizr wird dem HTML-Objekt eine der folgenden Klassen zuweisen, je nachdem ob der Browser WebSockets unterstützt oder nicht. */ . no-websockets . wsno , . websockets . wsyes { display : block ; } </ style > < script src = "path/to/modernizr.js" ></ script > </ head > < body > < p class = "wsno" > Dieser Browser unterstützt keine WebSockets. </ p > < p class = "wsyes" > Dieser Browser unterstützt WebSockets. </ p > </ body > </ html > Preise und Ehrungen [ Bearbeiten | Quelltext bearbeiten ] Sowohl 2010 als auch 2011 gewann Modernizr den „ .net Award for Open Source App of the Year “ und 2011 gewann einer der Hauptentwickler, Paul Irish, den „ Developer of the Year “-Preis. [ 17 ] Die Webseite gewann in den Kategorien Progressive Verbesserung und Responsive Webdesign den ersten respektive zweiten Platz in der „ List of Top Web Design Trends for 2012 “ des net magazines . [ 18 ] Siehe auch [ Bearbeiten | Quelltext bearbeiten ] WebSocket WebGL Weblinks [ Bearbeiten | Quelltext bearbeiten ] Drupal integration with Modernizr. Abgerufen im 1. Januar 1 W3C HTML5 W3C geolocation Web workers Web worker basics Enhancement with Modernizr and Yepnope Creating Cross Browser HTML5 Forms Now webdesignernote HTML Boilerplate in Ajaxian Archives Faruk Ateş: Proudly Announcing Modernizr. Abgerufen im 1. Januar 1 Speeding Up With Modernizr. Archiviert vom Original am 19. Dezember 2013 ; abgerufen im 1. Januar 1 . Mordernizr and Web Development. Abgerufen im 1. Januar 1 Einzelnachweise [ Bearbeiten | Quelltext bearbeiten ] ↑ a b Faruk Ateş: Modernizr goes 1.0! In: Modernizr. Abgerufen am 14. November 2015 (englisch). ↑ Contributors . In: GitHub. Abgerufen am 14. November 2015 (englisch). ↑ Modernizr Homepage. In: Modernizr. Abgerufen am 14. November 2015 (englisch, siehe Seitenfooter für Liste der Hauptentwickler). ↑ a b Releases . In: GitHub. Abgerufen am 14. August 2019 (englisch). ↑ registry.npmjs.com . In: npmjs . (abgerufen am 1. März 2023). ↑ a b c Modernizr Dokumentation. What is Modernizr . Abgerufen am 14. November 2015 (englisch): „ Modernizr is a small piece of JavaScript code that automatically detects the availability of next-generation web technologies in your user's browsers. “ ↑ Modernizr auf Github. Lizenz. In: GitHub . Abgerufen am 14. November 2015 (englisch). ↑ Modernizr 1.5: new features, unit tests added . In: Modernizr. 14. Juni 2015, abgerufen am 14. November 2015 (englisch). ↑ Entfernung der BSD-Lizenz. In: GitHub. Abgerufen am 14. November 2015 (englisch). ↑ modernizr.com . ↑ Faruk Ateş: Proudly Announcing: Modernizr. In: Faruk Ateş. 1. Juli 2009, abgerufen am 25. Dezember 2015 (englisch). ↑ Gil Fink: Detecting HTML5 Features Using Modernizr. In: codeproject.com. 10. Januar 2011, abgerufen am 25. Dezember 2015 . ↑ Daniel Sellergren: Using Modernizr to Determine HTML5 CSS3 Support. Februar 2011, archiviert vom Original am 22. August 2013 ; abgerufen am 25. Dezember 2015 (englisch). ↑ David Powers: Using Modernizr to detect HTML5 and CSS3 browser support. In: Adobe . 29. August 2011, abgerufen am 25. Dezember 2015 (englisch). ↑ HTML 5 elements in IE. ↑ HTML5 Cross Browser Polyfills ↑ .net Awards 2011:#7. ( Memento vom 11. März 2014 im Internet Archive ) ↑ 15 top web design and development trends for 2012. ( Memento vom 11. September 2013 im Internet Archive ) In: .net Abgerufen von „ https://de.wikipedia.org/w/index.php?title=Modernizr&oldid=242978238 “ Kategorien : HTML Web-Entwicklung Software Versteckte Kategorie: Wikipedia:Vorlagenfehler/Vorlage:Cite web/temporär Navigationsmenü Meine Werkzeuge Nicht angemeldet Diskussionsseite Beiträge Benutzerkonto erstellen Anmelden Namensräume Artikel Diskussion Deutsch Ansichten Lesen Bearbeiten Quelltext bearbeiten Versionsgeschichte Weitere Suche Navigation Hauptseite Themenportale Zufälliger Artikel Mitmachen Artikel verbessern Neuen Artikel anlegen Autorenportal Hilfe Letzte Änderungen Kontakt Spenden Werkzeuge Links auf diese Seite Änderungen an verlinkten Seiten Spezialseiten Permanenter Link Seiten­­informationen Artikel zitieren Kurzlink QR-Code herunterladen Drucken/​exportieren Als PDF herunterladen Druckversion In anderen Projekten Wikidata-Datenobjekt In anderen Sprachen العربية English فارسی Français Bahasa Indonesia 한국어 Polski Српски / srpski 中文 Links bearbeiten
